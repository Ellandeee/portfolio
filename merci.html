<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Message Envoyé - Ellande Cros</title>
    <link rel="stylesheet" href="styles/index.css">
    <link rel="stylesheet" href="styles/merci.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">

</head>
<body>

    <!-- FORMES FOND -->
    <div id="ambient-3d-scene"></div>

    <!-- CURSEUR CUSTOM -->
    <div id="custom-cursor"></div>

    <div class="merci-box">
        <h1>MESSAGE ENVOYÉ</h1>
        <p>Merci de m'avoir contacté. Je vous répondrai dans les plus brefs délais.</p>
        
        <a href="index.html" class="submit-btn" style="text-decoration: none;">
            RETOUR AU SITE
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="19" y1="12" x2="5" y2="12"></line>
                <polyline points="12 19 5 12 12 5"></polyline>
            </svg>
        </a>
    </div>


    <!-- "GPS" DE LA LAMPE TORCHE -->
    <script>
        const body = document.body;

        function updateHalo(e) {
            let x, y;
            
            // Si c'est un événement tactile
            if (e.touches && e.touches.length > 0) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } 
            // Si c'est un événement souris
            else {
                x = e.clientX;
                y = e.clientY;
            }

            body.style.setProperty('--mouse-x', x + 'px');
            body.style.setProperty('--mouse-y', y + 'px');
        }

        document.addEventListener('mousemove', updateHalo);
        document.addEventListener('touchmove', updateHalo, { passive: true });
        document.addEventListener('touchstart', updateHalo, { passive: true });
    </script>


    <!-- CURSEUR CUSTOM -->
    <script>
        const cursor = document.getElementById('custom-cursor');

        // 1. Mouvement instantané
        document.addEventListener('mousemove', (e) => {
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
        });

        // 2. Clic (Rapetissement)
        document.addEventListener('mousedown', () => cursor.classList.add('clicking'));
        document.addEventListener('mouseup', () => cursor.classList.remove('clicking'));

        // 3. Hover (Rotation + Agrandissement)
        // S'applique aux liens, boutons, cards, inputs et textareas
        const clickables = document.querySelectorAll('a, button, .project-card, input, textarea');

        clickables.forEach((el) => {
            el.addEventListener('mouseenter', () => cursor.classList.add('hovered'));
            el.addEventListener('mouseleave', () => cursor.classList.remove('hovered'));
        });
    </script>


    <!-- FORMES FOND -->
    <script>
        // FORMES FOND - VERSION OPTIMISÉE MOBILE
        const scene = document.getElementById('ambient-3d-scene');

        // Détection mobile et ajustement du nombre d'éléments
        const isMobile = window.innerWidth <= 768;
        const numberOfItems = isMobile ? 20 : 40; // BEAUCOUP MOINS sur mobile
        const safeZone = 5;
        const itemsPool = ['shape-triangle', '}', '{', '[', ']', '<', '>', '/', ';', '++', 'JS', 'C#', '//'];

        // --- REGLAGES DE LA PHYSIQUE  ---
        const shockRadius = isMobile ? 300 : 500;
        const shockPower = isMobile ? 15 : 25;
        const friction = 0.95;
        const returnFactor = 0.004;

        // --- VARIABLES SOURIS ---
        let targetMouseX = 0, targetMouseY = 0;
        let currentMouseX = 0, currentMouseY = 0;
        const mouseLerp = isMobile ? 0.1 : 0.05; // Plus réactif sur mobile

        const placedPositions = [];

        // --- GÉNÉRATION ---
        for (let i = 0; i < numberOfItems; i++) {
            let x, y, tooClose;
            let attempts = 0;
            do {
                x = Math.random() * 90 + 5;
                y = Math.random() * 90 + 5;
                tooClose = false;
                for (let pos of placedPositions) {
                    const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                    if (dist < safeZone) { tooClose = true; break; }
                }
                attempts++;
            } while (tooClose && attempts < 100);

            if (attempts < 100) {
                placedPositions.push({ x, y });
                const item = document.createElement('div');
                const content = itemsPool[Math.floor(Math.random() * itemsPool.length)];
                item.className = 'floating-mesh ' + (content.startsWith('shape-') ? content : 'char-item');
                if (!content.startsWith('shape-')) item.innerText = content;

                item.style.left = x + '%';
                item.style.top = y + '%';
                
                const depth = Math.random() * 0.7 + 0.1;
                item.dataset.depth = depth;
                item.style.scale = 0.4 + (depth * 0.8);

                // PHYSIQUE INDIVIDUELLE
                item.dataset.vx = 0;
                item.dataset.vy = 0;
                item.dataset.ox = 0;
                item.dataset.oy = 0;
                
                item.style.setProperty('--base-rotation', `${Math.random() * 360}deg`);
                item.style.animationDuration = `${8 + Math.random() * 8}s`;
                item.style.animationDelay = `${Math.random() * -15}s`;

                scene.appendChild(item);
            }
        }

        // --- ÉCOUTEURS (SOURIS + TACTILE) ---
        function handleMove(e) {
            let x, y;
            if (e.touches && e.touches.length > 0) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else {
                x = e.clientX;
                y = e.clientY;
            }
            targetMouseX = (x / window.innerWidth) - 0.5;
            targetMouseY = (y / window.innerHeight) - 0.5;
        }

        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: true });

        // Désactiver l'interaction au clic sur mobile
        document.addEventListener('mousedown', (e) => {
            const clickX = e.clientX;
            const clickY = e.clientY;
            const meshes = document.querySelectorAll('.floating-mesh');

            meshes.forEach(mesh => {
                const rect = mesh.getBoundingClientRect();
                const meshX = rect.left + rect.width / 2;
                const meshY = rect.top + rect.height / 2;

                const dx = meshX - clickX;
                const dy = meshY - clickY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < shockRadius) {
                    const depth = parseFloat(mesh.dataset.depth);
                    const impulse = (1 - distance / shockRadius) * shockPower * depth;
                    
                    mesh.dataset.vx = (dx / distance) * impulse;
                    mesh.dataset.vy = (dy / distance) * impulse;
                    
                    // Allumer temporairement l'élément lors de l'onde de choc
                    mesh.classList.add('lit');
                    setTimeout(() => {
                        mesh.classList.remove('lit');
                    }, 300);
                }
            });
        });

        // --- BOUCLE D'ANIMATION ---
        let lastTime = performance.now();
        const targetFPS = isMobile ? 30 : 60; // 30 FPS sur mobile
        const frameDelay = 1000 / targetFPS;

        function update(currentTime) {
            const deltaTime = currentTime - lastTime;
            
            // Limiter le framerate sur mobile
            if (deltaTime < frameDelay) {
                requestAnimationFrame(update);
                return;
            }
            
            lastTime = currentTime - (deltaTime % frameDelay);
            
            currentMouseX += (targetMouseX - currentMouseX) * mouseLerp;
            currentMouseY += (targetMouseY - currentMouseY) * mouseLerp;

            const meshes = document.querySelectorAll('.floating-mesh');
            meshes.forEach(mesh => {
                const depth = parseFloat(mesh.dataset.depth);
                let vx = parseFloat(mesh.dataset.vx);
                let vy = parseFloat(mesh.dataset.vy);
                let ox = parseFloat(mesh.dataset.ox);
                let oy = parseFloat(mesh.dataset.oy);

                // Effet de lumière (seulement sur desktop ou si peu de mouvement)
                const rect = mesh.getBoundingClientRect();
                const meshX = rect.left + rect.width / 2;
                const meshY = rect.top + rect.height / 2;

                const distToMouse = Math.sqrt(
                    Math.pow(targetMouseX * window.innerWidth + window.innerWidth/2 - meshX, 2) + 
                    Math.pow(targetMouseY * window.innerHeight + window.innerHeight/2 - meshY, 2)
                );

                if (distToMouse < 250) {
                    mesh.classList.add('lit');
                } else {
                    mesh.classList.remove('lit');
                }

                // Physique
                ox += vx;
                oy += vy;

                vx *= friction;
                vy *= friction;

                ox += (0 - ox) * returnFactor;
                oy += (0 - oy) * returnFactor;

                mesh.dataset.vx = vx;
                mesh.dataset.vy = vy;
                mesh.dataset.ox = ox;
                mesh.dataset.oy = oy;

                // Rendu
                const parallaxMultiplier = isMobile ? 100 : 200; // Moins de mouvement sur mobile
                const finalX = (currentMouseX * depth * parallaxMultiplier) + ox;
                const finalY = (currentMouseY * depth * parallaxMultiplier) + oy;
                
                mesh.style.translate = `${finalX}px ${finalY}px`;
            });

            requestAnimationFrame(update);
        }

        update(performance.now());
    </script>

</body>
</html>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Message Envoyé - Ellande Cros</title>
    <link rel="stylesheet" href="styles/index.css">
    <link rel="stylesheet" href="styles/merci.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">

</head>
<body>

    <!-- FORMES FOND -->
    <div id="ambient-3d-scene"></div>

    <!-- CURSEUR CUSTOM -->
    <div id="custom-cursor"></div>

    <div class="merci-box">
        <h1>MESSAGE ENVOYÉ</h1>
        <p>Merci de m'avoir contacté. Je vous répondrai dans les plus brefs délais.</p>
        
        <a href="index.html" class="submit-btn" style="text-decoration: none;">
            RETOUR AU SITE
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="19" y1="12" x2="5" y2="12"></line>
                <polyline points="12 19 5 12 12 5"></polyline>
            </svg>
        </a>
    </div>


    <!-- "GPS" DE LA LAMPE TORCHE -->
    <script>
        const body = document.body;
            document.addEventListener('mousemove', (e) => {
                // On met à jour les variables CSS avec la position X et Y de la souris
                body.style.setProperty('--mouse-x', e.clientX + 'px');
                body.style.setProperty('--mouse-y', e.clientY + 'px');
            });
    </script>


    <!-- CURSEUR CUSTOM -->
    <script>
        const cursor = document.getElementById('custom-cursor');

        // 1. Mouvement instantané
        document.addEventListener('mousemove', (e) => {
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
        });

        // 2. Clic (Rapetissement)
        document.addEventListener('mousedown', () => cursor.classList.add('clicking'));
        document.addEventListener('mouseup', () => cursor.classList.remove('clicking'));

        // 3. Hover (Rotation + Agrandissement)
        // S'applique aux liens, boutons, cards, inputs et textareas
        const clickables = document.querySelectorAll('a, button, .project-card, input, textarea');

        clickables.forEach((el) => {
            el.addEventListener('mouseenter', () => cursor.classList.add('hovered'));
            el.addEventListener('mouseleave', () => cursor.classList.remove('hovered'));
        });
    </script>


    <!-- FORMES FOND -->
    <script>
        const scene = document.getElementById('ambient-3d-scene');
        const numberOfItems = 80;
        const safeZone = 5;
        const itemsPool = ['shape-triangle', '}', '{', '[', ']', '<', '>', '/', ';', '++', 'JS', 'C#', '//'];

        // --- REGLAGES DE LA PHYSIQUE  ---
        const shockRadius = 500;      // Rayon d'action
        const shockPower = 25;        // Moins violent (poussée initiale faible)
        const friction = 0.95;        // Les objets glissent et s'arrêtent lentement
        const returnFactor = 0.004;   // RETOUR TRÈS LENT (presque imperceptible au début)

        // --- VARIABLES SOURIS ---
        let targetMouseX = 0, targetMouseY = 0;
        let currentMouseX = 0, currentMouseY = 0;
        const mouseLerp = 0.05;

        const placedPositions = [];

        // --- GÉNÉRATION ---
        for (let i = 0; i < numberOfItems; i++) {
            let x, y, tooClose;
            let attempts = 0;
            do {
                x = Math.random() * 90 + 5;
                y = Math.random() * 90 + 5;
                tooClose = false;
                for (let pos of placedPositions) {
                    const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                    if (dist < safeZone) { tooClose = true; break; }
                }
                attempts++;
            } while (tooClose && attempts < 100);

            if (attempts < 100) {
                placedPositions.push({ x, y });
                const item = document.createElement('div');
                const content = itemsPool[Math.floor(Math.random() * itemsPool.length)];
                item.className = 'floating-mesh ' + (content.startsWith('shape-') ? content : 'char-item');
                if (!content.startsWith('shape-')) item.innerText = content;

                item.style.left = x + '%';
                item.style.top = y + '%';
                
                const depth = Math.random() * 0.7 + 0.1;
                item.dataset.depth = depth;
                item.style.scale = 0.4 + (depth * 0.8);

                // PHYSIQUE INDIVIDUELLE
                item.dataset.vx = 0; // Vélocité X
                item.dataset.vy = 0; // Vélocité Y
                item.dataset.ox = 0; // Offset X
                item.dataset.oy = 0; // Offset Y
                
                item.style.setProperty('--base-rotation', `${Math.random() * 360}deg`);
                item.style.animationDuration = `${8 + Math.random() * 8}s`;
                item.style.animationDelay = `${Math.random() * -15}s`;

                scene.appendChild(item);
            }
        }

        // --- ÉCOUTEURS ---
        document.addEventListener('mousemove', (e) => {
            targetMouseX = (e.clientX / window.innerWidth) - 0.5;
            targetMouseY = (e.clientY / window.innerHeight) - 0.5;
        });

        document.addEventListener('mousedown', (e) => {
            const clickX = e.clientX;
            const clickY = e.clientY;
            const meshes = document.querySelectorAll('.floating-mesh');

            meshes.forEach(mesh => {
                const rect = mesh.getBoundingClientRect();
                const meshX = rect.left + rect.width / 2;
                const meshY = rect.top + rect.height / 2;

                const dx = meshX - clickX;
                const dy = meshY - clickY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < shockRadius) {
                    const depth = parseFloat(mesh.dataset.depth);
                    // On donne une VITESSE de départ, pas une position
                    const impulse = (1 - distance / shockRadius) * shockPower * depth;
                    
                    mesh.dataset.vx = (dx / distance) * impulse;
                    mesh.dataset.vy = (dy / distance) * impulse;
                }
            });
        });

        // --- BOUCLE D'ANIMATION ---
        function update() {
            currentMouseX += (targetMouseX - currentMouseX) * mouseLerp;
            currentMouseY += (targetMouseY - currentMouseY) * mouseLerp;

            const meshes = document.querySelectorAll('.floating-mesh');
            meshes.forEach(mesh => {
                const depth = parseFloat(mesh.dataset.depth);
                let vx = parseFloat(mesh.dataset.vx);
                let vy = parseFloat(mesh.dataset.vy);
                let ox = parseFloat(mesh.dataset.ox);
                let oy = parseFloat(mesh.dataset.oy);

                const rect = mesh.getBoundingClientRect();
                const meshX = rect.left + rect.width / 2;
                const meshY = rect.top + rect.height / 2;

                // Distance entre la souris réelle (e.clientX/Y) et l'objet
                // Note : Utilise les variables globales mouseX/Y que tu as déjà
                const distToMouse = Math.sqrt(
                    Math.pow(targetMouseX * window.innerWidth + window.innerWidth/2 - meshX, 2) + 
                    Math.pow(targetMouseY * window.innerHeight + window.innerHeight/2 - meshY, 2)
                );

                // Si la souris est à moins de 250px, on allume
                if (distToMouse < 250) {
                    mesh.classList.add('lit');
                } else {
                    mesh.classList.remove('lit');
                }

                // 1. APPLIQUER LA VITESSE À L'OFFSET
                ox += vx;
                oy += vy;

                // 2. FRICTION (Fait que l'objet s'arrête de glisser au loin)
                vx *= friction;
                vy *= friction;

                // 3. RETOUR TRÈS LENT (L'élastique mou)
                ox += (0 - ox) * returnFactor;
                oy += (0 - oy) * returnFactor;

                // Sauvegarde
                mesh.dataset.vx = vx; mesh.dataset.vy = vy;
                mesh.dataset.ox = ox; mesh.dataset.oy = oy;

                // 4. RENDU FINAL
                const finalX = (currentMouseX * depth * 200) + ox;
                const finalY = (currentMouseY * depth * 200) + oy;
                
                mesh.style.translate = `${finalX}px ${finalY}px`;
            });

            requestAnimationFrame(update);
        }

        update();
    </script>

</body>
</html>